Perfect—let’s turn this into small, verifiable steps. No code; just crisp specs, field names, and checklists so we can implement in bite-sizes.

# Phase 0 — Finalize names & constants (20–30 min)

**Capabilities:** `Read`, `Metadata`, `Write`, `Move`, `Link`
**Drop effects (policy output):** `copy`, `move`, `link`
**Traffic-light status:** `allowed` (green), `needsConsent` (yellow), `denied` (red)

**DenyRecord (host, short-lived)**

* `widgetId` (string)
* `widgetHash` (string)
* `scopePrefix` (string; normalized path/virtual scope)
* `capabilities` (string[]) — requested caps
* `reason` (`user-deny` | `elevation-failed` | `policy`)
* `ts` (number; epoch ms)
* `ttlMs` (number) → compute `expiresAt = ts + ttlMs`
* (optional) `sticky` (boolean; set when user chose a persistent “deny this in future”)

**Per-drag session cache key (web)**

* `(targetWid, targetHash, targetScopePrefix, requiredCaps[], sourceWid?)`

---

# Phase 1 — `authz:check` v2 (non-breaking)

**Caller:** web DnD preflight on `dragover`
**Input (unchanged where possible):**

* `widgetId`, `widgetHash`
* `targetScopePrefix`
* `requiredCaps[]`
* (optional) `sourceScopePrefix` (for move policy), `sourceWid`

**Response (BC-safe):**

* `ok: boolean` (legacy)
* `status: 'allowed' | 'needsConsent' | 'denied'`
* `denied?: boolean` (duplicate of `status==='denied'`, for old consumers)
* `effects?: ('copy'|'move'|'link')[]` (allowed by tickets+policy)
* `reason?: string` (e.g., `user-deny`, `missing-ticket`, `policy`)
* `suggestedScope?: string` (narrowest useful ask for the consent modal)
* `ticketTtlMs?: number` (for optional cache honoring)

**Acceptance**

* If a valid ticket covers `(targetScopePrefix, requiredCaps[])` → `status=allowed`, `ok=true`.
* If no ticket and no matching DenyRecord → `status=needsConsent`, `ok=false`.
* If a matching, unexpired DenyRecord → `status=denied`, `ok=false`, `reason='user-deny'` (or other).
* Effects reflect copy/move/link policy (Phase 7), not just tickets.

---

# Phase 2 — Deny ledger (host, source-of-truth complement)

**Storage:** in-memory with TTL; optional persistent if `sticky=true`.
**APIs (host-internal):**

* `DenyLedger.record(record: DenyRecord)`
* `DenyLedger.clear(widgetId, widgetHash, scopePrefix, capabilities[])`
* `DenyLedger.match(widgetId, widgetHash, scopePrefix, capabilities[]) -> DenyRecord | null`

**When to write:**

* User presses **Deny** in consent modal → `reason='user-deny'`.
* Elevation failed irrecoverably → `reason='elevation-failed'`.
* Policy hard-forbids → `reason='policy'`.

**TTL guidance:**

* Default: session or 10–30 minutes.
* If user checked a persistent “deny future requests,” set `sticky=true` and a long TTL (hours/days) until changed.

**Acceptance**

* Red is shown while a matching deny exists (prefix-match on scope, not expired).
* Clicking **Change access…** in the hint opens modal; a successful grant **clears** the matching deny.

---

# Phase 3 — Per-drag DnD auth cache (web)

**Lifecycle:** created on `dragstart`, cleared on `dragend`.
**Value:** `{ status, effects, reason?, suggestedScope?, fetchedAt }`
**Behavior:**

* Use cache immediately on `dragover`. If miss, rAF-throttle an `authz:check`.
* On consent grant/deny, update/expire any entries for that `(wid, scopePrefix, caps)`.

**Acceptance**

* Hovering the same target twice within one drag uses cached result (no IPC spam).
* Cache respects ticket TTL if `ticketTtlMs` is returned (optional).

---

# Phase 4 — Hint UX with click-to-elevate

**When Yellow:** show hint/snackbar near target.

* Primary action: **Grant access…** → opens consent modal immediately.
* If granted → run the drop action; if denied → write DenyRecord and switch to red next time.
* Use your snackbar `id` + `dedupe` to prevent spam; `neverLabel` only hides the hint UI, not permissions.

**When Red:** show hint “Access denied for this location.”

* Primary action: **Change access…** → opens the consent modal (lets users override a prior deny).

**Acceptance**

* Hints appear at most once per target per hover (deduped).
* User can complete the operation from the hint without re-dragging.

---

# Phase 5 — DOM DnD wiring (traffic lights)

**Behaviors:**

* Deepest eligible drop target “wins.”
* On `dragover`: query cache → apply `.gex-drop-allowed` / `.gex-drop-caution` / `.gex-drop-denied`.
* Map platform modifiers to a requested effect (subject to `effects` from policy). If requested not allowed, fall back to best allowed.
* Throttle preflights (rAF), and debounce class flips to reduce flicker.

**Acceptance**

* Only one target shows a state at a time; visuals switch cleanly.
* Denied targets never execute on drop unless user has elevated first via hint.

---

# Phase 6 — OS → app drop ingestion via FsBridge

**Goal:** make OS drops indistinguishable from in-app payloads.

**Host addition:** one message that takes OS paths/URIs and returns canonical refs + safe metadata (batch).

* Normalizes path, resolves shortcuts, attaches icon keys/size/mime when cheap.
* Runs no destructive operations; just describe payloads.

**Web flow:** upon seeing `DataTransfer.files` / `text/uri-list`, call ingestion, then continue as with any payload.

**Acceptance**

* Dropping files from Explorer/Finder behaves exactly like dragging from Items.

---

# Phase 7 — Copy/Move/Link policy + elevation

**Policy inputs:** `(sourceScopePrefix?, targetScopePrefix, requestedCaps, sameVolume?)`
**Outputs:** `effects[]` and (optionally) a **default** effect.

**Semantics (typical):**

* Same scope + Write: `move` and `copy` allowed.
* Cross volume with Write: `copy` (and `move` if you implement cross-volume move).
* No Write: maybe `link` if your app supports links/shortcuts.

**Execution path:**

* Green: execute immediately.
* Yellow: trigger consent; if elevation needed, use your SecurePipe channel.
* Red: do nothing unless user overrides via hint → modal → ticket minted.

**Acceptance**

* Modifiers reflect platform norms (Win: Ctrl=Copy; Mac: Option=Copy); cursor/dropEffect matches the final chosen effect.
* Elevation path handles file ops cleanly, with robust error → hint flows.

---

# Phase 8 — Instrumentation & debug

* **Debug overlay** (toggle): show current winner target, status, effect, and which cache entry hit.
* **Logs/metrics:** count preflights, grants, denies, elevation successes/failures, OS-drop ingestion time.

**Acceptance**

* Easy to diagnose why a drop is red/yellow/green without stepping through code.

---

## Quick pilot plan (2–3 short PRs)

1. **Authz v2 + Deny ledger** (host only).
   Ship `authz:check` tri-state + effects; backfill from Tickets + Deny.
   *Validate with a tiny manual harness (call from console / a hidden dev panel).*

2. **Per-drag cache + traffic-light classes** (web).
   No functional drop yet—just visuals + hints wired to open ConsentModal.

3. **Consent-on-drop + OS ingestion**.
   Hook the modal to mint tickets; pipe OS drops through FsBridge ingestion; complete actions for a single happy path (copy file in Items → Items).

We’ll keep each PR testable with the Items and Weather widgets you already trust for consent behavior.

If you want, I can turn this into issue stubs (titles, scope, acceptance) you can paste into your tracker.
